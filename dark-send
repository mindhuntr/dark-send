#!/usr/bin/env python3

from telethon.tl.types import DocumentAttributeVideo,InputMessagesFilterPhotos
from telethon.errors import FilePartsInvalidError
from telethon import TelegramClient 
from datetime import datetime 
from inquirer import display_list
from telethon.sessions import StringSession 
from meta_data import meta_extract
from argparse import ArgumentParser 
from os import path, listdir
import progress_bar, shutil, subprocess, mimetypes
import tempfile
import config 

""" Get api id and hash from https://my.telegram.org """ 

async def main(): 
    
    parser = ArgumentParser(description='command line telegram client') 
    parser.add_argument('message', type=str,help="the message you would like to send",nargs="*") 
    parser.add_argument('-v','--video',type=str,nargs="+",help="videos to send") 
    parser.add_argument('-i','--image',type=str,nargs="+",help="images to send") 
    parser.add_argument('-f','--file',type=str,nargs="+",help="files to send")
    parser.add_argument('-p','--compressed',type=str,nargs="+",help="send files as compressed (both images and videos)" ) 
    parser.add_argument('-n','--nchats',type=int,nargs="?",default=20,help="no chats to display") 
    parser.add_argument('-c','--chats',type=str,nargs="*",help="name of the chat") 
    parser.add_argument('-a','--album',action="store_true",help="send files as albums") 
    parser.add_argument('-q','--quiet',action="store_true",help="suppress progress bar") 
    parser.add_argument('--download-images',action="store_true",help="download photos from selected chats") 
    parser.add_argument('--download-media',type=int,nargs="+",help="download selected media from chats (use message id)") 

    chats = [] 
    mimetypes.init()
    args = parser.parse_args() 

    chat_list = { 
            dialog.name:dialog.id async for dialog in client.iter_dialogs(args.nchats)
            }

    ## Send Message 

    if args.message:
        if not chats:
            chats = await display_list(args.nchats,args.chats,chat_list) # Display chat list 

        if chats:
            for message in args.message: 
                for chat in chats:
                    await client.send_message(chat,message) # Send message to selected chats

    ## Send Videos 
    
    if args.video:
        if not chats:
            chats = await display_list(args.nchats,args.chats,chat_list)  

        if chats:
            for video in args.video: 
                if path.exists(video):
                    height, width, duration = meta_extract(video) # Extract metadata for video
                    for chat in chats:
                        if not args.quiet:
                            video_handle = await client.upload_file(video,progress_callback=progress_bar.progress,part_size_kb=512) # Upload video with progress 
                            await client.send_file(chat,video_handle,video=True,attributes=(DocumentAttributeVideo(duration,width,height,supports_streaming=True),)) # Send the video
                        else:
                            video_handle = await client.upload_file(video,part_size_kb=512) # Upload video without progress 
                            await client.send_file(chat,video_handle,video=True,attributes=(DocumentAttributeVideo(duration,width,height,supports_streaming=True),)) 
                else:
                    print("{} doesnt exist".format(video)) 

    ## Send both videos and images as compressed 

    if args.compressed: 
        if not chats:
            chats = await display_list(args.nchats,args.chats,chat_list)

        if chats:
            for comps in args.compressed: 
                if path.exists(comps):
                    mime_out = mimetypes.guess_type(comps)[0] 
                    if mime_out and mime_out.split('/')[0] == "image": # Check if image 
                        for chat in chats:
                            if not args.quiet:
                                image_handle = await client.upload_file(comps,progress_callback=progress_bar.progress,part_size_kb=512)
                                await client.send_file(chat,image_handle,image=True) 
                            else:
                                image_handle = await client.upload_file(comps,part_size_kb=512)
                                await client.send_file(chat,image_handle,image=True) 

                    if mime_out and mime_out.split('/')[0] == "video": # Check if video 
                            height, width, duration = meta_extract(comps)  # Extract metadata 
                            for chat in chats:
                                if not args.quiet:
                                    video_handle = await client.upload_file(comps,progress_callback=progress_bar.progress,part_size_kb=512)
                                    await client.send_file(chat,video_handle,video=True,attributes=(DocumentAttributeVideo(duration,width,height,supports_streaming=True),)) 
                                else:
                                    video_handle = await client.upload_file(comps,part_size_kb=512)
                                    await client.send_file(chat,video_handle,video=True,attributes=(DocumentAttributeVideo(duration,width,height,supports_streaming=True),)) 

                else:
                    print("{} doesnt exist".format(comps)) 

    ## Send Images 

    if args.image:
        if not args.album:
            if not chats:
                chats = await display_list(args.nchats,args.chats,chat_list) 
            if chats:
                for image in args.image:
                    if path.exists(image):
                        for chat in chats:
                            if not args.quiet:
                                # image_handle = await client.upload_file(image,progress_callback=progress_bar.progress,part_size_kb=512)
                                await client.send_file(chat,image,image=True,progress_callback=progress_bar.progress,part_size_kb=512) 
                            else:
                                # image_handle = await client.upload_file(image,part_size_kb=512)
                                await client.send_file(chat,image,image=True,part_size_kb=512) 
                    else:
                        print("{} doesnt exist".format(image)) 
        else:                                                           # Send images as an album 
            if not chats:
                chats = await display_list(args.nchats,args.chats,chat_list) 

            if chats:
                for chat in chats:
                    if not args.quiet:
                        await client.send_file(chat,args.image,progress_callback=progress_bar.progress,part_size_kb=512,image=True)
                    else: 
                        await client.send_file(chat,args.image,part_size_kb=512,image=True)

    ## Send files 
    if args.file:
        if not args.album:
            if not chats:
                chats = await display_list(args.nchats,args.chats,chat_list) 
            if chats:
                for file in args.file:
                    if path.exists(file):
                        for chat in chats:
                            if not args.quiet:
                                if path.getsize(file)/(1024*1024) < 2000: 
                                    await client.send_file(chat,file,force_document=True,progress_callback=progress_bar.progress,part_size_kb=512) 
                                else: 
                                    print("File too big. Splitting into parts...") 
                                    part_files = rar_file(file) 

                                    for part_file in part_files:
                                        await client.send_file(chat,part_file,force_document=True,progress_callback=progress_bar.progress,part_size_kb=512) 

                                    shutil.rmtree(path.dirname(part_files[0]))
                            else:
                                if path.getsize(file)/(1024*1024) < 2000: 
                                    await client.send_file(chat,file,force_document=True,part_size_kb=512) 

                                else: 
                                    print("File too big. Splitting into parts...") 
                                    part_files = rar_file(file) 

                                    for part_file in part_files:
                                        await client.send_file(chat,part_file,force_document=True,part_size_kb=512) 
                                
                                    shutil.rmtree(path.dirname(part_files[0]))
                    else:
                        print("{} doesnt exist".format(file)) 

        else: 
            if not chats:
                chats = await display_list(args.nchats,args.chats,chat_list) 
            files_to_upload = []
            
            if chats:
                for file in args.file:
                    if path.exists(file):
                        if path.getsize(file)/(1024*1024) >= 2000: 
                            print("File too big. Splitting into parts....") 
                            part_files = rar_file(file)

                            for part_file in part_files: 
                                files_to_upload.append(part_file) 
                        else: 
                            files_to_upload.append(file) 
                    else:
                        print("{} doesnt exist".format(file)) 

                if files_to_upload:
                    for chat in chats:
                        if not args.quiet:
                            await client.send_file(chat,files_to_upload,force_document=True,progress_callback=progress_bar.progress,part_size_kb=512) 
                        else: 
                            await client.send_file(chat,files_to_upload,force_document=True,part_size_kb=512) 
                            
                    rm_dirs = []
                    for file in files_to_upload: 
                        if '/tmp/' in file: 
                            if path.basename(file) not in rm_dirs:
                                rm_dirs.append(path.basename(file))

                    for dir in rm_dirs: 
                        res = input("Would you like to remove {}? (y/n).".format(dir))
                        if res.lower() == 'y':
                            shutil.rmtree(dir)

    if args.download_images: 

        if not chats:
            chats = await display_list(args.nchats,args.chats,chat_list)  

        if chats:
            for chat in chats: 
                async for message in client.iter_messages(chat,filter=InputMessagesFilterPhotos):
                    now = datetime.now() 
                    current_time = now.strftime("%Y_%m_%d_%H_%M_%S")

                    file_name = "image_" + current_time + ".jpg" 
                    with open(file_name,'wb') as file:
                        await client.download_media(message,file,progress_callback=progress_bar.progress) 

    if args.download_media: 

        if not chats: 
            chats = await display_list(args.nchats,args.chats,chat_list)

        if chats:
            for chat in chats: 
                async for message in client.iter_messages(chat): 
                    if (not args.download_media) or (min(args.download_media) > message.id): 
                        break 
                    if message.id in args.download_media: 
                        try:
                            if message.media.document.mime_type: 
                                tp, _ = message.media.document.mime_type.split('/')
                                if tp == "application": 
                                    file_name = message.file.name
                                    with open(file_name,'wb') as file:
                                        await client.download_media(message,file,progress_callback=progress_bar.progress) 

                                elif tp == "video": 
                                    now = datetime.now() 
                                    current_time = now.strftime("%Y_%m_%d_%H_%M_%S")

                                    file_name = "video_" + current_time + ".mp4" 
                                    with open(file_name,'wb') as file:
                                        await client.download_media(message,file,progress_callback=progress_bar.progress) 

                        except AttributeError: 
                            if hasattr(message.media,'photo'): 
                                now = datetime.now() 
                                current_time = now.strftime("%Y_%m_%d_%H_%M_%S")

                                file_name = "image_" + current_time + ".jpg" 
                                with open(file_name,'wb') as file:
                                    await client.download_media(message,file,progress_callback=progress_bar.progress) 
                            else: 
                                continue 
                            
                        args.download_media.remove(message.id) 


def rar_file(input_file): 
    
    try: 
        subprocess.Popen(['rar',], stdout=subprocess.PIPE, stderr=subprocess.PIPE) 
    except FileNotFoundError: 
        print("rar not found. Please install")
        exit(1)

    arc_file = "/" + path.splitext(path.basename(input_file))[-2] + ".rar"
    tmp_dir = tempfile.mkdtemp()
    arc_path = tmp_dir + arc_file

    subprocess.run(['rar', 'a', '-v2G', '-R', arc_path, input_file]) 

    rar_files = []
    for file in listdir(tmp_dir):
        rar_files.append(tmp_dir + "/" + file) 

    return rar_files

if __name__ == "__main__":

    if path.exists(config.fullpath):

        config.parser.read(config.fullpath) 
        api_id = int(config.parser.get('dark-send','api_id'))
        api_hash = config.parser.get('dark-send','api_hash') 
        string = config.parser.get('dark-send','string_session') 

    else:
        config.generate_conf() 
        config.parser.read(config.fullpath) 
        api_id = int(config.parser.get('dark-send','api_id'))
        api_hash = config.parser.get('dark-send','api_hash') 
        string = config.parser.get('dark-send','string_session') 

    client = TelegramClient(StringSession(string), api_id, api_hash) 

    with client:
        client.loop.run_until_complete(main())

