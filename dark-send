#!/usr/bin/env python3

from telethon.tl.types import DocumentAttributeVideo, InputMessagesFilterPhotos, InputMessagesFilterMusic
from telethon.tl.types import InputMessagesFilterVideo, InputMessagesFilterDocument
from telethon.tl.functions.channels import GetForumTopicsRequest
from meta_data import meta_extract
from telethon.sessions import StringSession
from telethon import TelegramClient, utils
from FastTelethon import upload_file
from argparse import ArgumentParser
from inquirer import display_list
from datetime import datetime
from telethon.tl import types
from os import path, remove
import socket
import progress_bar
import mimetypes
import asyncio 
import config
import json 
import sys

""" Get api id and hash from https://my.telegram.org """

SOCK_PATH = "/tmp/dark-send.sock" 


async def daemonize(): 

    if path.exists(config.fullpath):
        config.parser.read(config.fullpath)
        api_id = int(config.parser.get('dark-send', 'api_id'))
        api_hash = config.parser.get('dark-send', 'api_hash')
        string = config.parser.get('dark-send', 'string_session')

    else:
        config.generate_conf()
        config.parser.read(config.fullpath)
        api_id = int(config.parser.get('dark-send', 'api_id'))
        api_hash = config.parser.get('dark-send', 'api_hash')
        string = config.parser.get('dark-send', 'string_session')

    client = TelegramClient(StringSession(string), api_id, api_hash)
    await client.start()

    # clean up old socket
    if path.exists(SOCK_PATH):
        remove(SOCK_PATH)

    server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    server.bind(SOCK_PATH)
    server.listen(5)

    print(f"dark-send daemon listening on {SOCK_PATH}")

    def upload_progress(current, total):
        update = json.dumps({"type": "progress", "current": current, "total": total})
        conn.send(update.encode())

    sock_buf = ""

    while True:
        conn, _ = server.accept()
        cmd_arr = []

        while True:
            sock_buf += conn.recv(4096).decode() 

            while "\n" in sock_buf: 
                line, sock_buf = sock_buf.split("\n", 1)
                if not line.strip(): 
                    continue 
                cmd = json.loads(line) 
                print(cmd)

                if cmd["type"] == "end": 
                    break 

                cmd_arr.append(cmd) 

            if cmd_arr and cmd["type"] == "end":
                break

        try:
            for cmd in cmd_arr:
                if cmd["type"] == "send_message":
                    await client.send_message(cmd["chat"], cmd["text"], reply_to=cmd["reply_to"])

                elif cmd["type"] == "send_image": 
                    if cmd["quiet"] == False: 
                        await client.send_file(
                            cmd["chat"], cmd["image"],
                            image=True,
                            part_size_kb=512, caption=cmd["caption"],
                            reply_to=cmd["reply_to"],
                            progress_callback=upload_progress
                                        )
                    else: 
                        await client.send_file(
                            cmd["chat"], cmd["image"],
                            image=True,
                            part_size_kb=512, caption=cmd["caption"],
                            reply_to=cmd["reply_to"],
                                        )

                elif cmd["type"] == "send_video":
                    if cmd["quiet"] == False:
                        video_handle = await client.upload_file(
                            cmd["video"],
                            progress_callback=upload_progress,
                            part_size_kb=512)
                    else: 
                        video_handle = await client.upload_file(
                            cmd["video"],
                            part_size_kb=512)

                    await client.send_file(
                        cmd["chat"], video_handle,
                        video=True, attributes=(DocumentAttributeVideo(cmd["duration"], cmd["width"], cmd["height"], supports_streaming=True),),
                        reply_to=cmd["reply_to"], caption=cmd["caption"]
                        )

                elif cmd["type"] == "send_file": 
                    if cmd["quiet"] == "False":
                        await client.send_file(
                            cmd["chat"], cmd["file"],caption=cmd["caption"], 
                            reply_to=cmd["reply_to"], progress_callback=upload_progress, force_document=True
                        )
                    else: 
                        await client.send_file(
                            cmd["chat"], cmd["file"],caption=cmd["caption"], 
                            reply_to=cmd["reply_to"], force_document=True
                        )

                else:
                    conn.send(b"unknown command")

        except Exception as e:
            conn.send(str(e).encode())
        finally:
            sock_buf = ""
            conn.close() 

async def cli(args):

    chats = []
    chat_list = {}
    mimetypes.init()
    chat_path = path.join(path.dirname(config.fullpath), "chats.json")

    if len(sys.argv) == 1:
        parser.print_help()
        exit()

    async def get_chats():
        nonlocal chat_list
        async for dialog in client.iter_dialogs(args.nchats):
            if not hasattr(dialog.entity, "forum"):
                chat_list[dialog.name] = dialog.id
            else:
                if dialog.entity.forum:
                    topic_obj = await client(GetForumTopicsRequest(
                        channel=dialog.id, offset_date=datetime.now(),
                        offset_id=1, offset_topic=1, limit=100))

                    topics = [{topic.title: topic.id} for topic in topic_obj.topics]
                    chat_list[dialog.name] = [dialog.id, topics]
                else:
                    chat_list[dialog.name] = dialog.id

    async def reload_chats(): 
        await get_chats() 
        with open(chat_path, 'w') as chat_file: 
            json.dump(chat_list, chat_file) 

    async def load_chats(): 
        nonlocal chat_list
        with open(chat_path, 'r') as chat_file: 
            chat_list = json.load(chat_file) 

    def display_progress(): 
        while True:
            data = sock.recv(4096).decode()
            for line in data.splitlines():
                msg = json.loads(line)
                current = msg["current"]
                total = msg["total"]
                progress_bar.progress(current, total) 

            if current == total:
                break


    if path.exists(chat_path) and not args.refresh: 
        await load_chats() 
    else: 
        await reload_chats() 

    if not args.caption:
        args.caption = [None]

    if not chats:
        chats = await display_list(args.nchats, args.chats, chat_list)  # Display chat list

    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(SOCK_PATH)


    # Send Message
    async def send_message(chats, messages):
        for message in messages:
            for chat in chats:
                cmd = {"type": "send_message", "chat": chat[0], "text": message, "reply_to": chat[1]}
                sock.send((json.dumps(cmd) + "\n").encode())
                # await client.send_message(chat[0],
                #                           message, reply_to=chat[1])

        cmd = {"type": "end"} 
        sock.send((json.dumps(cmd) + "\n").encode())

    # Send Videos
    async def send_videos(chats, videos):
        for video in videos:
            if path.exists(video):
                height, width, duration = meta_extract(video)
                for chat in chats:
                    cmd = {
                        "type": "send_video", "chat": chat[0], 
                        "video": path.abspath(video), "caption": args.caption[0], 
                        "reply_to": chat[1],
                        "height": height, "width": width, "duration": duration,
                        "quiet": args.quiet 
                    }

                    sock.send((json.dumps(cmd) + "\n").encode())
            else:
                print("{} doesnt exist".format(video))

        cmd = {"type": "end"} 
        sock.send((json.dumps(cmd) + "\n").encode())

        if not args.quiet: 
            count = len(videos) * len(chats) 
            for i in range(0, count): 
                display_progress()


    # Send Images
    async def send_images(chats, images):
        if not args.album:
            for image in images:
                if path.exists(image):
                    for chat in chats:
                        cmd = {
                            "type": "send_image", "chat": chat[0], 
                            "image": path.abspath(image), "caption": args.caption[0], 
                            "reply_to": chat[1], "quiet": args.quiet 
                        }

                        sock.send((json.dumps(cmd) + "\n").encode())
                else:
                    print("{} doesnt exist".format(image))

        else:                                                           # Send images as an album 
            for chat in chats:
                image_paths = [ path.abspath(image) for image in images ]
                cmd = {
                    "type": "send_image", "chat": chat[0], 
                    "image": image_paths, "caption": args.caption[0], 
                    "reply_to": chat[1], "quiet": args.quiet
                }
                sock.send((json.dumps(cmd) + "\n").encode())


        cmd = {"type": "end"} 
        sock.send((json.dumps(cmd) + "\n").encode())

        if not args.quiet: 
            if not args.album:
                count = len(images) * len(chats) 
            else:
                count = len(chats) 
            for i in range(0, count): 
                display_progress() 


    # Send files
    async def send_files(chats, files):
        if not args.album:
            for file in files:
                if path.exists(file):
                    for chat in chats:
                        cmd = {
                            "type": "send_file", "chat": chat[0], 
                            "file": path.abspath(file), "caption": args.caption[0], 
                            "reply_to": chat[1], "quiet": args.quiet
                        }
                        sock.send((json.dumps(cmd) + "\n").encode())
                else:
                    print("{} doesnt exist".format(file))

        else:
            files_album = []
            for file in files:
                if path.exists(file):
                    files_album.append(path.abspath(file))
                else:
                    print("{} doesnt exist".format(file))

            if files_album:
                for chat in chats:
                    cmd = {
                        "type": "send_file", "chat": chat[0], 
                        "file": files_album, "caption": args.caption[0], 
                        "reply_to": chat[1], "quiet": args.quiet
                    }
                    sock.send((json.dumps(cmd) + "\n").encode())

        cmd = {"type": "end"} 
        sock.send((json.dumps(cmd) + "\n").encode())

        if not args.quiet: 
            if not args.album:
                count = len(files) * len(chats) 
            else:
                count = len(chats) 
            for i in range(0, count): 
                display_progress() 

    async def download_images(chats):
        for chat in chats:
            async for message in client.iter_messages(chat[0], filter=InputMessagesFilterPhotos):
                now = datetime.now()
                current_time = now.strftime("%Y_%m_%d_%H_%M_%S")

                file_name = "image_" + current_time + ".jpg"
                with open(file_name, 'wb') as file:
                    await client.download_media(
                        message, file,
                        progress_callback=progress_bar.progress
                    )

    async def download_videos(chats):
        for chat in chats:
            async for message in client.iter_messages(chat[0], filter=InputMessagesFilterVideo):
                now = datetime.now()
                current_time = now.strftime("%Y_%m_%d_%H_%M_%S")

                file_name = "video" + current_time + ".mp4"
                with open(file_name, 'wb') as file:
                    await client.download_media(
                        message, file,
                        progress_callback=progress_bar.progress
                    )
    async def download_audio(chats): 
        for chat in chats:
            async for message in client.iter_messages(chat[0], filter=InputMessagesFilterMusic):
                with open(message.file.name.replace('/','-'), 'wb') as file:
                    await client.download_media(
                        message, file,
                        progress_callback=progress_bar.progress
                    )

    async def download_documents(chats): 
        for chat in chats:
            async for message in client.iter_messages(chat[0], filter=InputMessagesFilterDocument):
                with open(message.file.name.replace('/','-'), 'wb') as file:
                    await client.download_media(
                        message, file,
                        progress_callback=progress_bar.progress
                    )

    async def download_all_media(chats):
        await download_images(chats)
        await download_videos(chats)
        await download_audio(chats)
        await download_documents(chats)

    if args.message:
        await send_message(chats, args.message)
    elif args.image:
        await send_images(chats, args.image)
    elif args.video:
        await send_videos(chats, args.video)
    elif args.file:
        await send_files(chats, args.file)
    elif args.download_media == "image":
        await download_images(chats)
    elif args.download_media == "video":
        await download_videos(chats)
    elif args.download_media == "audio":
        await download_audio(chats)
    elif args.download_media == "file":
        await download_documents(chats)
    elif args.download_media == "all":
        await download_all_media(chats)



#     if args.clone:
#         chats = await display_list(args.nchats,args.chats,chat_list) # Display chat list
#         dest_chat = await display_list(args.nchats,args.chats,chat_list) # Display chat list
#         album = []
#
#         for chat in chats:
#             async for message in client.iter_messages(chat,min_id=14171,reverse=True):
#                 if type(message) is Message
#                     if type(message.media) is MessageMediaPhoto
#                         if album:
#                             await client.forward_messages(dest_chat[0], album, drop_author=True)
#                             sleep(1)
#                             album = [
#                         await client.send_message(dest_chat[0], message)
#
#                     if type(message.media) is MessageMediaDocument:
#                         album.append(message)



async def main():

    parser = ArgumentParser(description='command line telegram client')
    parser.add_argument('message', type=str, help="the message you would like to send", nargs="*")
    parser.add_argument("--daemon", action="store_true", help="Run in daemon mode")
    parser.add_argument('-v', '--video', type=str, nargs="+", help="videos to send")
    parser.add_argument('-i', '--image', type=str, nargs="+", help="images to send")
    parser.add_argument('-f', '--file', type=str, nargs="+", help="files to send")
    parser.add_argument('-n', '--nchats', type=int, nargs="?", default=100, help="no chats to display")
    parser.add_argument('-c', '--chats', type=str, nargs="*", help="name of the chat")
    parser.add_argument('-t', '--caption', type=str, nargs="*", help="caption for file")
    parser.add_argument('-a', '--album', action="store_true", help="send files as albums")
    parser.add_argument('-q', '--quiet', action="store_true", help="suppress progress bar")
    parser.add_argument('-r', '--refresh', action="store_true", help="refresh local chat store")
    parser.add_argument('--download-media', choices=['image', 'video', 'file', 'audio', 'all'] , help="download all media from chats")

    args = parser.parse_args()

    if args.daemon:
        await daemonize()
    else:
        await cli(args)

    # with TelegramClient(StringSession(string), api_id, api_hash) as client:
    #     client.loop.run_until_complete(main())


if __name__ == "__main__":
    asyncio.run(main())
